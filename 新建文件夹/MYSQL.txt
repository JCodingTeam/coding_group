查询优化
1.分区表(通常按月份,入库日期)
优点:(1)存不同磁盘的话 比存同个磁盘能存更多的数据;
(2)涉及到例如SUM()和COUNT()这样聚合函数的查询,多个分区并行,速度提升
(3)主要还是查询时,大大减少检索的数据量
2.建索引,优化索引(最优先考虑) 大大提升查询速度,提升分组,排序速度
查询语句尽量走索引,避免不走索引的查询 ,如前缀模糊搜索 使用EXPLAIN可以看执行情况,主键最先考虑 其他索引次之
负向条件有：!=、<>、not in、not exists、not like等 转化为in 前缀% 尽量去掉,或者转化为in
索引段使用函数进行计算会导致无法命中索引 应避免,而应该尽量在业务代码进行,把计算放到业务层。这样做不仅可以节省数据库的 CPU，还可以起到查询缓存优化效果。比如下面的 SQL 语句：select * from order where timestamp(date) < = CURDATE() select * from order where date < = '2018-01-2412:00:00'(索引列参与计算，相当于新生成了一个临时列，这个临时列上是没有索引的)
(a,b,c) a>1 and b>1 z只能用到a这个 b,c无法使用索引
单列索引尽量非null 复合索引不全为null
如果明确知道只有一条结果返回，limit 1 能够提高效率。
可以的话避免回表查询(索引字段已经包含了返回的数据)
重复值少,值域大的字段建立索引时,如果用到通常能起到很好的效果,相反 重复值多,值域小的字段 建立索引意义不是很大 比如性别只有两种值 (组合索引也要注意索引区分度高的尽量在左边)
常常一起使用的多个查询条件应该考虑复合索引,同时应注意复合索引顺序 ,如存在业务上唯一特性的字段 考虑建成唯一性索引
分页查询偏移量太大 查询变慢(自增主键 ,找到主键再去用主键查快很多)
索引也不能建太多 动态维护索引需要空间成本,时间成本(增删改)
索引字段应该避免过长,如过长又必须建索引可以考虑短索引(前缀索引)
频繁更新的字段不适合创建索引，因为每次更新不单单是更新了记录还会更新索引，加重了IO负担