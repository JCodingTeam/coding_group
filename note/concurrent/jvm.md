###### 运行时数据区域

1. 程序计数器

   可以看作是当前线程所执行的字节码的行号指示器。

   线程私有，此内存区域是在JVM规范中唯一没有规定`OutOfMemoryError`情况的区域。

2. 虚拟机栈

   线程私有，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直到执行完成的过程就对应一个栈帧在虚拟机栈中入栈到出栈。

   在JVM规范中，对这个区域规定了两种Error情况：`OutOfMemoryError`和`StackOverflowError`

3. 本地方法栈

   本地方法栈和虚拟机栈的作用是非常相似的，只不过区别是本地方法栈执行Native方法，而虚拟机栈执行的是Java方法。

4. Java堆

   Java堆是被所有线程共享的一块内存区域，在JVM启动时创建。此内存区域的目的是存放对象实例，几乎所有的对象实例及数组都是在堆上分配内存。

   Java堆是垃圾收集器管理的主要区域，也叫GC堆。

5. 方法区

   用于存储已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

   1.8之前：使用永久代实现， 1.8：使用元空间实现。



###### 对象创建

类加载->分配内存->初始化

为对象实例分配内存的方法

1. 指针碰撞

   假设堆内存是绝对规整的，由指针指示器作为已使用内存和空闲内存的分界点，那么分配内存只需要将指针指示器移动和对象大小相等的距离。

2. 空闲列表

   如果堆内存中已使用内存和空闲内存相互交错，使用这种方式时，JVM会维护一个记录可用内存块的列表，在分配时从列表中找到足够大的空间划分给对象实例。

   

分配内存时的线程安全问题解决方法

1. `CAS`

2. 本地线程缓存

   每个线程在堆中预先分配一小块内存，用于分配新对象的内存。只有`TLAB`用完并分配`TLAB`时才需要同步锁定。

   使用`TLAB`可以通过-XX: +/- UseTLAB参数来设定



###### 对象的内存布局

对象在内存的存储布局分为三部分：对象头(Header)、实例数据(Instance Data)、对齐填充(Padding)

而对象头则存储：Mark Word、指向类元信息的指针`Class MetaData Address`、`ArrayLength`（如果是数组对象的话）

```java
Mark word                            :state
hashcode|age|biased_lock:0       |01 : normal
threadID|epoch|age|biased_lock:1 |01 : Biased
ptr_to_record                    |00 : lightweight locked
ptr_to_heavyweight_monitor       |10 : heavyweight locked
                                 |11 : marked for gc
```



###### 对象的访问定位

通过栈的reference数据来操作堆上的具体对象，使用reference来访问对象的方式有：

1. 使用句柄访问

   Java堆中划分出一块内存作为句柄池，reference存储的是对象的句柄地址，而句柄中包含了对象实例数据和类元信息的各自的具体地址信息。

2. 使用引用访问

   reference存储的是对象在堆中的具体地址。

两种方式各自的优势：

句柄方式在对象被回收时移动时只需要改变句柄池中的实例数据指针，不需要改变reference的值。引用方式则省去一次指针定位的开销。





###### 判断对象是否已死

可达性分析法：

当对象到`GC Roots`没有任何引用链相连，则说明该对象是不可用的。在Java中，可作为`GC Roots`的对象有以下几种：

1. Java虚拟栈的栈帧的局部变量表中引用的对象
2. 本地方法栈的`JNI`引用的对象
3. 方法区中的常量引用的对象
4. 方法区中类的静态变量引用的对象





###### 引用的类型

1. 强引用：类似`Object obj = new Object()`这类的引用，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。
2. 软引用：实现类`SoftReference`，在将要发生`OOMError`之前，会对软引用关联着的对象进行回收。
3. 弱引用：实现类`WeakReference`，当垃圾收集器工作时，无论是否内存足够，都会回收掉弱引用关联的对象。
4. 虚引用：实现类`PhantomReference`，为对象设置虚引用关联后无法通过虚引用来取得对象实例，仅用于在这个对象被垃圾回收时收到一个系统通知。





###### 方法区的回收

方法区可以被回收，而垃圾收集的主要内容主要有两个：

1. 常量：回收废弃常量和回收Java堆的对象类似，没有任何地方引用到该常量时，可以被回收。
2. 类：类的所有实例都已被回收，加载该类的`ClassLoader`已被回收，该类的Class对象没有任何地方引用。





###### 垃圾收集算法

主要的垃圾收集算法

1. 标记清除算法（Mark-Sweep）

   算法分为标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

   最大的不足是空间问题，标记清除后产生大量不连续的内存碎片，空间碎片太多可能导致以后分配较大对象时无法找到大的连续内存而触发另一次的垃圾收集动作。

2. 复制算法（Copying）

   将可用内存划分为两块，每次只使用其中一块，垃圾回收时，将这一块使用中的存活对象复制到另一块中，并清理原来使用中的块的内存空间。不足是用于分配对象的内存缩小为其中的一块。

   `HotSpot`虚拟机将新生代的可用内存空间划分为`Eden`和两个`Survivor`，使用`Eden`和其中一个`Survivor`(记为`s0`)作为可用内存空间，当垃圾收集时，将`Eden`和`s0`上存活的对象复制到另一个`Survivor`(记为`s1`)上，并清理掉`Eden`和`s0`的空间，再使用`Eden`和`s1`作为可用内存空间。默认`Eden`和`Survivor`比例是`8:1`（`-XX: SurvivorRatio=8`），此时可用内存空间为新生代容量的90%。

   当`Eden`和`s0`上存活对象大于`s1`的空间时，需要依赖老年代的内存进行分配担保，这时候这些存活对象通过分配 担保机制直接进入老年代。

   复制算法适用于只有少量对象存活的情况，因此老年代不能选用复制算法。

3. 标记整理算法（Mark-Compact）

   标记整理算法适用于老年代选用的算法。算法分为标记-整理两个阶段，首先标记需要回收的对象，接着让所有存活的对象都向一端移动，最后再清理掉端边界以外的内存。

4. 分代收集算法（Generational Collection）

   把Java堆划分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。新生代采用复制算法，老年代选用标记清除或标记整理算法。



算法实现

枚举根节点分析结果准确性的保证：需要在整个分析期间停顿所有的Java线程（这个事件称为`Stop the world`，停顿线程的方式有抢先式中断和主动式中断）

主动式中断：当`GC`需要中断线程时，仅简单地设置中断标志，各个线程执行时在每一个安全区域内都主动去轮询这个标志，发现中断标志为真时就把自己的线程挂起。

安全区域：在一段代码片段中，引用关系不会发生变化，是安全点的扩展。

在`GC`发生时，程序首先运行到最近的一个安全点（`SafePoint`）停下来，然后更新`OopMap`，最后进行枚举根节点时，遍历`RememberedSet`和每个栈帧中的`OopMap`，通过记录的被引用对象的内存地址快速的找到`GC Roots`的对象。

使用`OopMap`记录栈上本地变量到堆上对象的引用关系（用空间换时间的思想，遍历`OopMap`中记录的栈上局部变量，而不是遍历所有局部变量）

使用`RememberedSet`记录位于Java堆不同划分区域之间的对象的引用关系



`JVM`运行模式：

1. client：采用轻量级的`JVM`，启动速度快
2. server：采用重量级的`JVM`，对程序采用了更多的优化，启动较慢，但启动进入稳定期后运行速度比client更快





###### 垃圾收集器

![1586421510718](.\1586421510718.png)





1. `Serial`收集器

   一个`GC`线程和用户线程串行执行，新生代使用复制算法，老年代使用标记整理算法。

   虚拟机运行在`Client`模式下的默认新生代收集器

   ![1586419986815](.\1586419986815.png)

2. `ParNew`收集器

   是`Serial`收集器的多线程版本，多个并行的`GC`线程和用户线程串行执行

   运行在`Server`模式下首选的新生代收集器

   ![1586420232986](.\1586420232986.png)

3. `Parallel Scavenge`收集器

   和`ParNew`收集器特点类似，适用于新生代的收集器，使用复制算法，多个`GC`线程。但`Parallel Scavenge`收集器更关注于吞吐量。

   `Parallel Scavenge`收集器的目标是精准控制吞吐量，高吞吐量表示 高效率地利用CPU时间完成程序的运算任务，主要适用于后台运算而不需要太多交互的场景（交互场景则需要stop the world停顿时间短）。吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。

4. Serial Old 收集器

   Serial Old收集器是Serial收集器的老年代版本，单`GC`线程收集，使用标记整理算法。主要在于`Client`模式下使用。在`server`模式下作为`CMS`收集器的后备预案。

5. Parallel Old收集器

   Parallel Old是Parallel Scavenge收集器的老年代版本，使用多个`GC`线程和标记整理算法。在注重吞吐量以及CPU资源敏感的场景下，可以考虑Parallel Scavenge加Parallel Old收集器。

6. `CMS`收集器（`Concurrent Mark Sweep`）

   目标是获取最短的回收停顿时间。适用于对服务响应和交互体验要求高的场景。特点：并发收集、低停顿。

   运行过程分为4个步骤：初始标记，并发标记，重新标记，并发清除（并发标记与并发清除两个步骤的执行可以和用户线程并行执行）

   ![1586424680103](.\1586424680103.png)

   

   问题：

   1. 并发标记/并发清理过程占用CPU线程从而降低吞吐量
   2. 产生空间内存碎片
   3. 无法处理浮动垃圾，需要预留空间给用户线程（由于并发清理，需要预留空间给用户线程使用，当预留空间不足以使用时，会出现`Concurrent Mode Failure`失败，此时使用后备预案进行`FullGC`）

7. `G1`收集器（`Garbage First`）

   以收集尽可能多的垃圾为原则，面向服务端应用的垃圾收集器，特点：并行与并发、分代收集、空间整合（从整体上看是基于标记整理算法，从Region之间是基于复制算法）、可预测的停顿。

   ![1586425634721](.\1586425634721.png)

   

   

   

   

   

   `JVM`常见参数

   `-XX:NewRatio` 表示：老年代/新生代的比值 。例如：`-XX:NewRatio=4` 表示老年代/新生代=`4:1`，即新生代占Java堆空间的20%

   `-XX:SurvivorRatio`表示 `Eden/Survivor`的比值。例如：`-XX:SurvivorRatio=8`表示`Eden：Survivor`=`8:1`，即每一个Survivor占新生代空间的10%

   ![1586428901599](.\1586428901599.png)

   ![1586428912824](.\1586428912824.png)

   





###### 内存分配与回收策略

对象的内存分配：主要分配在新生代的`Eden`区上，如果启动了本地线程分配缓冲，则按线程优先在`TLAB`上分配。少数情况下直接分配在老年代中。

1. 大多数情况下，对象在Eden上分配，当Eden区没有足够的空间时进行分配时，会触发一次`Minor GC`。
2. 大对象直接进入老年代，（`-XX:PretenureSizeThreshold`直接晋升到老年代对象的大小）
3. 长期存活的对象将进入老年代，当对象每进过一次`Minor GC`，年龄便增加1，当年龄超过晋升老年代的年龄阈值时，对象将被晋升到老年代中（`-XX:MaxTenuringThreshold`晋升到老年代的年龄）
4. 动态对象年龄判定，如果在Survivor空间中相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，而无需等到超过`MaxTenuringThreshold`的值。



空间分配担保

在发生`Minor GC`之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象的总空间，如果这个条件成立，那么`Minor GC`是可以确保安全的。如果不成立，则通过`HandlePromotionFailure`设置值是否允许担保失败。如果允许，则继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果大于则进行`Minor GC`（如果出现担保失败，只能在失败后重新发起一次`Full GC`），如果小于则改为进行`Full GC`。





###### 类加载机制

类加载机制：虚拟机把描述欸的数据从Class文件（这里指的是以各种形式存在的二进制的字节流）加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被使用的Java类型。

类的生命周期：加载->验证->准备->解析->初始化->使用->卸载。其中验证、准备、解析这三个部分统称为连接。

![1586432766564](.\1586432766564.png)





虚拟机规范定义了有且只有5种情况（对类进行主动引用）必须立即对类进行初始化，而加载、连接的过程自然需要在此之前开始。

1. 遇到`new`（实例化对象）、`getstatic`（读取静态字段的值）、 `putstatic`（设置静态字段的值）、 `invokestatic`（调用静态方法）这4个字节码指令时，如果对应的类没有进行过初始化，则需要先触发其初始化。（通过子类引用父类的静态字段，只会进行父类的初始化不会导致子类初始化）（通过数组定义来引用类，不会触发此类的初始化。创建动作由`newarray`触发，初始化的类为`[Lpackage.Class`）
2. 使用`java.lang.reflect`包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类的时候，如果其父类还没进行过初始化，则需要先触发其父类的初始化。（接口在初始化时并不要求其父接口全部都完成了初始化，只有在真正使用到父接口时才会初始化）
4. 当虚拟机启动时，虚拟机会初始化包含main方法的主类。
5. 如果使用`java.lang.invoke.MethodHandle`的返回`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`的方法句柄，并且方法句柄对应的类还没进行过初始化，则需要先触发其初始化。	





类加载的过程

1. 加载

   在加载阶段，虚拟机需要完成以下3件事情：

   1. 通过一个类的全限定类名来获取定义此类的二进制字节流。
   2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
   3. 在内存中（并没有明确规定是在Java堆中）生成代表整个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。

2. 验证

   验证阶段主要完成：文件格式验证、元数据验证、字节码验证、符号引用验证。

3. 准备

   准备阶段，是正式为类变量分配内存（在方法区中进行分配）并设置类变量（不包括实例变量）初始值的阶段。如果类变量被final修饰，则使用代码中指定的值作为初始值。

4. 解析

   解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。

5. 初始化

   初始化阶段是执行类构造器`<clinit>`方法的过程，`<clinit>`是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（`static`{}块）中的语句合并产生的。编译器收集顺序是由语句在源文件中出现顺序所决定的。静态代码块中只能访问在静态代码块之前的变量，定义在它之后的变量，在静态代码块中只能赋值，但不能访问。

   虚拟机会保证在子类的`<clinit>`方法执行之前，父类的`<clinit>`方法已经执行完毕。



###### 双亲委派模型

从Java开发人员的角度来看，有三种系统提供的类加载器：

1. 启动类加载器（`Bootstrap ClassLoader`）：负责加载`<JAVA_HOME>\lib`目录中或者被`-Xbootclasspath`参数所指定的路径中，并且是虚拟机识别的类库。
2. 扩展类加载器（`Extension ClassLoader`）：负责加载`<JAVA_HOME>\lib\ext`目录中或者被`java.ext.dirs`系统变量所指定的路径中的所有类库。
3. 应用程序类加载器（`Application ClassLoader`）：负责加载用户类路径（`ClassPath`）上的类库，程序中默认的类加载器，可以通过`ClassLoader.getSystemClassLoader()`获取。

双亲委派模型的工作过程：

如果一个类加载器收到了类加载的请求，首先检查请求的类是否已经被加载过，如果不是，则将这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此，所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器返回无法完成加载请求时（在搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。

![1586438423978](.\1586438423978.png)







































































